#include <cmath>
#include <iostream>
#include "lodepng.h"
#include <chrono>
#include <thrust/complex.h>
#include <cuda_runtime.h>

using namespace std;
typedef long long ll;

const int bit_color = 8;
const int h = 512, w = h;
const double xmax = 2.0, xmin = -2.0;
// // const double cx = 0, cy = 0.8;
const double xresolution = (xmax-xmin)/w;
// const double yresolution = (xmax-xmin)/h;
// const int threshold = pow(10,2);
// unsigned low_itr = 300, high_itr = 0;

class Timer {
    // using declarations for improving readability of the code
    using hrc =  chrono::high_resolution_clock;
    using time_point =  chrono::time_point<hrc>;
    using micro_sec =  chrono::microseconds;
    using milli_sec = chrono::milliseconds;
    using sec = chrono::seconds;
    typedef long long  ll;

    private:
        time_point start_time_;
        time_point stop_time_;
        ll duration_ {0};

    public:
        Timer() = default;
        ~Timer() = default;

        void start(){
            start_time_ = hrc::now();
        }

        void stop(){
            stop_time_ = hrc::now();
        }

        ll duration_us(){
            auto s =  chrono::time_point_cast<micro_sec>(start_time_).time_since_epoch().count();
            auto e =  chrono::time_point_cast<micro_sec>(stop_time_).time_since_epoch().count();
            duration_ = e - s; 
            return duration_;
        }

        ll duration_ms(){
            auto s =  chrono::time_point_cast<milli_sec>(start_time_).time_since_epoch().count();
            auto e =  chrono::time_point_cast<milli_sec>(stop_time_).time_since_epoch().count();
            duration_ = e - s; 
            return duration_;
        }

        ll duration_s(){
            auto s =  chrono::time_point_cast<sec>(start_time_).time_since_epoch().count();
            auto e =  chrono::time_point_cast<sec>(stop_time_).time_since_epoch().count();
            duration_ = e - s; 
            return duration_;
        }
        
};

void initBG(unsigned char* img){
    for (int i = 0; i<w*h*3; i+=3) {
        img[i+1] = 0; 
        img[i+2] = 0;
    }
}
void cudasafe(int error, string message="(---)", string file = "(-this file-)", int line = -1) {
    if (error != cudaSuccess) {
            cout<<stderr<< " CUDA Error: "<<message<<" : "<<error<<". In "<<file<<" line "<<line<<endl; 
            exit(-1);
    }
}
__global__ void setv(int* image, const double cx,const double cy,const int w,
     const int xmin, const int xresolution){

    int idx = blockIdx.x * 32*32 + threadIdx.y * 32 + threadIdx.x;

    thrust::complex<double> z (xmin + (idx%w)*xresolution , xmin + (idx/w)*xresolution);
    thrust::complex<double> c (cx,cy);

    unsigned i = 0;
   
    while((z.real()*z.real() + z.imag()*z.imag()) <100 && i<300){
        z = z*z + c ;
        ++i;
    }
    
    image[idx] = idx;
}
void createImg(double cx, double cy, string filename = "juliaCPUx.png"){
    unsigned char* img = new unsigned char [w*h*3];
    int* image = new int [w*h];
    int* d_img;
    cudasafe(cudaMalloc(&d_img, w*h*sizeof(int)), "Mem Allo", __FILE__,__LINE__);
    dim3 blocks(32,32);
    dim3 grids(w*h/pow(32,2));
    // cout<<"going inside device!\n";
    setv <<< grids, blocks >>> (d_img,cx,cy,w, xmin, xresolution);
    initBG(img);
    cudasafe(cudaDeviceSynchronize(),"Sync", __FILE__,__LINE__);
    // cout<<"got out of device!\n";
    // 
    cudasafe(cudaMemcpy(image, d_img, w*h*sizeof(int), cudaMemcpyDeviceToHost), "Mem Trans", __FILE__,__LINE__);
    for(int i=0; i<w*h; i++)cout<<image[i]<<"  ";
    for (int i = 0; i<w*h*3; i+=3) {
        img[i] = static_cast<unsigned char>(image[i/3]);
        // cout<<image[i/3]<<endl;    
    }
    cudasafe(cudaFree(d_img),"Mem free", __FILE__,__LINE__);
    // delete[] image;
    lodepng::encode(filename, img, w, h, LCT_RGB, bit_color);
    delete[] img;

}

int main(int argc, char* argv[]){
    Timer t;
    t.start();
    createImg(stof(argv[1]), stof(argv[2]), argv[3]);
    t.stop();
    cout<<"\n\n Total time taken: "<< t.duration_s()<<"  s = "<<t.duration_ms()<<"  ms"<<endl;
    return 0;
}